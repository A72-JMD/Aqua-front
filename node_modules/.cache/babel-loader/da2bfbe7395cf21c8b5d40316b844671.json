{"ast":null,"code":"import { makeCamelCaseArray, makeCamelCase } from './Utils';\nfunction getBoundingBox(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCase(geometry.BoundingBox);\n}\nfunction getPolygon(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCaseArray(geometry.Polygon);\n}\n/**\n * Organizes blocks from Rekognition API to each of the categories and and structures\n * their data accordingly.\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeRekognitionBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  };\n  // We categorize each block by running a forEach loop through them.\n  blocks.forEach(function (block) {\n    switch (block.Type) {\n      case 'LINE':\n        response.text.lines.push(block.DetectedText);\n        response.text.linesDetailed.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: null\n        });\n        break;\n      case 'WORD':\n        response.text.fullText += block.DetectedText + ' ';\n        response.text.words.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        break;\n    }\n  });\n  // remove trailing space of fullText\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n  return response;\n}\n/**\n * Organizes blocks from Textract API to each of the categories and and structures\n * their data accordingly.\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeTextractBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  };\n  // if blocks is an empty array, ie. textract did not detect anything, return empty response.\n  if (blocks.length === 0) return response;\n  /**\n   * We categorize each of the blocks by running a forEach loop through them.\n   *\n   * For complex structures such as Tables and KeyValue, we need to trasverse through their children. To do so,\n   * we will post-process them after the for each loop. We do this by storing table and keyvalues in arrays and\n   * mapping other blocks in `blockMap` (id to block) so we can reference them easily later.\n   *\n   * Note that we do not map `WORD` and `TABLE` in `blockMap` because they will not be referenced by any other\n   * block except the Page block.\n   */\n  var tableBlocks = Array();\n  var keyValueBlocks = Array();\n  var blockMap = {};\n  blocks.forEach(function (block) {\n    switch (block.BlockType) {\n      case 'LINE':\n        response.text.lines.push(block.Text);\n        response.text.linesDetailed.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: block.Page\n        });\n        break;\n      case 'WORD':\n        response.text.fullText += block.Text + ' ';\n        response.text.words.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n      case 'SELECTION_ELEMENT':\n        var selectionStatus = block.SelectionStatus === 'SELECTED' ? true : false;\n        if (!response.text.selections) response.text.selections = [];\n        response.text.selections.push({\n          selected: selectionStatus,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n      case 'TABLE':\n        tableBlocks.push(block);\n        break;\n      case 'KEY_VALUE_SET':\n        keyValueBlocks.push(block);\n        blockMap[block.Id] = block;\n        break;\n      default:\n        blockMap[block.Id] = block;\n    }\n  });\n  // remove trailing space in fullText\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n  // Post-process complex structures if they exist.\n  if (tableBlocks.length !== 0) {\n    var tableResponse_1 = Array();\n    tableBlocks.forEach(function (table) {\n      tableResponse_1.push(constructTable(table, blockMap));\n    });\n    response.text.tables = tableResponse_1;\n  }\n  if (keyValueBlocks.length !== 0) {\n    var keyValueResponse_1 = Array();\n    keyValueBlocks.forEach(function (keyValue) {\n      // We need the KeyValue blocks of EntityType = `KEY`, which has both key and value references.\n      if (keyValue.EntityTypes.indexOf('KEY') !== -1) {\n        keyValueResponse_1.push(constructKeyValue(keyValue, blockMap));\n      }\n    });\n    response.text.keyValues = keyValueResponse_1;\n  }\n  return response;\n}\n/**\n * Constructs a table object using data from its children cells.\n * @param {Textract.Block} table - Table block that has references (`Relationships`) to its cells\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructTable(table, blockMap) {\n  var tableMatrix;\n  tableMatrix = [];\n  // visit each of the cell associated with the table's relationship.\n  table.Relationships.forEach(function (tableRelation) {\n    tableRelation.Ids.forEach(function (cellId) {\n      var cellBlock = blockMap[cellId];\n      var row = cellBlock.RowIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n      var col = cellBlock.ColumnIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n      // extract data contained inside the cell.\n      var content = extractContentsFromBlock(cellBlock, blockMap);\n      var cell = {\n        text: content.text,\n        boundingBox: getBoundingBox(cellBlock.Geometry),\n        polygon: getPolygon(cellBlock.Geometry),\n        selected: content.selected,\n        rowSpan: cellBlock.RowSpan,\n        columnSpan: cellBlock.ColumnSpan\n      };\n      if (!tableMatrix[row]) tableMatrix[row] = [];\n      tableMatrix[row][col] = cell;\n    });\n  });\n  var rowSize = tableMatrix.length;\n  var columnSize = tableMatrix[0].length;\n  // Note that we leave spanned cells undefined for distinction\n  return {\n    size: {\n      rows: rowSize,\n      columns: columnSize\n    },\n    table: tableMatrix,\n    boundingBox: getBoundingBox(table.Geometry),\n    polygon: getPolygon(table.Geometry)\n  };\n}\n/**\n * Constructs a key value object from its children key and value blocks.\n * @param {Textract.Block} KeyValue - KeyValue block that has references (`Relationships`) to its children.\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructKeyValue(keyBlock, blockMap) {\n  var keyText = '';\n  var valueText = '';\n  var valueSelected;\n  keyBlock.Relationships.forEach(function (keyValueRelation) {\n    if (keyValueRelation.Type === 'CHILD') {\n      // relation refers to key\n      var contents = extractContentsFromBlock(keyBlock, blockMap);\n      keyText = contents.text;\n    } else if (keyValueRelation.Type === 'VALUE') {\n      // relation refers to value\n      keyValueRelation.Ids.forEach(function (valueId) {\n        var valueBlock = blockMap[valueId];\n        var contents = extractContentsFromBlock(valueBlock, blockMap);\n        valueText = contents.text;\n        if (contents.selected != null) valueSelected = contents.selected;\n      });\n    }\n  });\n  return {\n    key: keyText,\n    value: {\n      text: valueText,\n      selected: valueSelected\n    },\n    polygon: getPolygon(keyBlock.Geometry),\n    boundingBox: getBoundingBox(keyBlock.Geometry)\n  };\n}\n/**\n * Extracts text and selection from input block's children.\n * @param {Textract.Block}} block - Block that we want to extract contents from.\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\nexport function extractContentsFromBlock(block, blockMap) {\n  var words = '';\n  var isSelected;\n  if (!block.Relationships) {\n    // some block might have no content\n    return {\n      text: '',\n      selected: undefined\n    };\n  }\n  block.Relationships.forEach(function (relation) {\n    relation.Ids.forEach(function (contentId) {\n      var contentBlock = blockMap[contentId];\n      if (contentBlock.BlockType === 'WORD') {\n        words += contentBlock.Text + ' ';\n      } else if (contentBlock.BlockType === 'SELECTION_ELEMENT') {\n        isSelected = contentBlock.SelectionStatus === 'SELECTED' ? true : false;\n      }\n    });\n  });\n  words = words.substr(0, words.length - 1); // remove trailing space.\n  return {\n    text: words,\n    selected: isSelected\n  };\n}","map":{"version":3,"sources":["../../src/Providers/IdentifyTextUtils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { makeCamelCaseArray, makeCamelCase } from './Utils';\nfunction getBoundingBox(geometry) {\n    if (!geometry)\n        return undefined;\n    return makeCamelCase(geometry.BoundingBox);\n}\nfunction getPolygon(geometry) {\n    if (!geometry)\n        return undefined;\n    return makeCamelCaseArray(geometry.Polygon);\n}\n/**\n * Organizes blocks from Rekognition API to each of the categories and and structures\n * their data accordingly.\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeRekognitionBlocks(blocks) {\n    // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n    var response = {\n        text: {\n            fullText: '',\n            words: [],\n            lines: [],\n            linesDetailed: [],\n        },\n    };\n    // We categorize each block by running a forEach loop through them.\n    blocks.forEach(function (block) {\n        switch (block.Type) {\n            case 'LINE':\n                response.text.lines.push(block.DetectedText);\n                response.text.linesDetailed.push({\n                    text: block.DetectedText,\n                    polygon: getPolygon(block.Geometry),\n                    boundingBox: getBoundingBox(block.Geometry),\n                    page: null,\n                });\n                break;\n            case 'WORD':\n                response.text.fullText += block.DetectedText + ' ';\n                response.text.words.push({\n                    text: block.DetectedText,\n                    polygon: getPolygon(block.Geometry),\n                    boundingBox: getBoundingBox(block.Geometry),\n                });\n                break;\n        }\n    });\n    // remove trailing space of fullText\n    response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n    return response;\n}\n/**\n * Organizes blocks from Textract API to each of the categories and and structures\n * their data accordingly.\n * @param {Textract.BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeTextractBlocks(blocks) {\n    // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n    var response = {\n        text: {\n            fullText: '',\n            words: [],\n            lines: [],\n            linesDetailed: [],\n        },\n    };\n    // if blocks is an empty array, ie. textract did not detect anything, return empty response.\n    if (blocks.length === 0)\n        return response;\n    /**\n     * We categorize each of the blocks by running a forEach loop through them.\n     *\n     * For complex structures such as Tables and KeyValue, we need to trasverse through their children. To do so,\n     * we will post-process them after the for each loop. We do this by storing table and keyvalues in arrays and\n     * mapping other blocks in `blockMap` (id to block) so we can reference them easily later.\n     *\n     * Note that we do not map `WORD` and `TABLE` in `blockMap` because they will not be referenced by any other\n     * block except the Page block.\n     */\n    var tableBlocks = Array();\n    var keyValueBlocks = Array();\n    var blockMap = {};\n    blocks.forEach(function (block) {\n        switch (block.BlockType) {\n            case 'LINE':\n                response.text.lines.push(block.Text);\n                response.text.linesDetailed.push({\n                    text: block.Text,\n                    polygon: getPolygon(block.Geometry),\n                    boundingBox: getBoundingBox(block.Geometry),\n                    page: block.Page,\n                });\n                break;\n            case 'WORD':\n                response.text.fullText += block.Text + ' ';\n                response.text.words.push({\n                    text: block.Text,\n                    polygon: getPolygon(block.Geometry),\n                    boundingBox: getBoundingBox(block.Geometry),\n                });\n                blockMap[block.Id] = block;\n                break;\n            case 'SELECTION_ELEMENT':\n                var selectionStatus = block.SelectionStatus === 'SELECTED' ? true : false;\n                if (!response.text.selections)\n                    response.text.selections = [];\n                response.text.selections.push({\n                    selected: selectionStatus,\n                    polygon: getPolygon(block.Geometry),\n                    boundingBox: getBoundingBox(block.Geometry),\n                });\n                blockMap[block.Id] = block;\n                break;\n            case 'TABLE':\n                tableBlocks.push(block);\n                break;\n            case 'KEY_VALUE_SET':\n                keyValueBlocks.push(block);\n                blockMap[block.Id] = block;\n                break;\n            default:\n                blockMap[block.Id] = block;\n        }\n    });\n    // remove trailing space in fullText\n    response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n    // Post-process complex structures if they exist.\n    if (tableBlocks.length !== 0) {\n        var tableResponse_1 = Array();\n        tableBlocks.forEach(function (table) {\n            tableResponse_1.push(constructTable(table, blockMap));\n        });\n        response.text.tables = tableResponse_1;\n    }\n    if (keyValueBlocks.length !== 0) {\n        var keyValueResponse_1 = Array();\n        keyValueBlocks.forEach(function (keyValue) {\n            // We need the KeyValue blocks of EntityType = `KEY`, which has both key and value references.\n            if (keyValue.EntityTypes.indexOf('KEY') !== -1) {\n                keyValueResponse_1.push(constructKeyValue(keyValue, blockMap));\n            }\n        });\n        response.text.keyValues = keyValueResponse_1;\n    }\n    return response;\n}\n/**\n * Constructs a table object using data from its children cells.\n * @param {Textract.Block} table - Table block that has references (`Relationships`) to its cells\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructTable(table, blockMap) {\n    var tableMatrix;\n    tableMatrix = [];\n    // visit each of the cell associated with the table's relationship.\n    table.Relationships.forEach(function (tableRelation) {\n        tableRelation.Ids.forEach(function (cellId) {\n            var cellBlock = blockMap[cellId];\n            var row = cellBlock.RowIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n            var col = cellBlock.ColumnIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n            // extract data contained inside the cell.\n            var content = extractContentsFromBlock(cellBlock, blockMap);\n            var cell = {\n                text: content.text,\n                boundingBox: getBoundingBox(cellBlock.Geometry),\n                polygon: getPolygon(cellBlock.Geometry),\n                selected: content.selected,\n                rowSpan: cellBlock.RowSpan,\n                columnSpan: cellBlock.ColumnSpan,\n            };\n            if (!tableMatrix[row])\n                tableMatrix[row] = [];\n            tableMatrix[row][col] = cell;\n        });\n    });\n    var rowSize = tableMatrix.length;\n    var columnSize = tableMatrix[0].length;\n    // Note that we leave spanned cells undefined for distinction\n    return {\n        size: { rows: rowSize, columns: columnSize },\n        table: tableMatrix,\n        boundingBox: getBoundingBox(table.Geometry),\n        polygon: getPolygon(table.Geometry),\n    };\n}\n/**\n * Constructs a key value object from its children key and value blocks.\n * @param {Textract.Block} KeyValue - KeyValue block that has references (`Relationships`) to its children.\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructKeyValue(keyBlock, blockMap) {\n    var keyText = '';\n    var valueText = '';\n    var valueSelected;\n    keyBlock.Relationships.forEach(function (keyValueRelation) {\n        if (keyValueRelation.Type === 'CHILD') {\n            // relation refers to key\n            var contents = extractContentsFromBlock(keyBlock, blockMap);\n            keyText = contents.text;\n        }\n        else if (keyValueRelation.Type === 'VALUE') {\n            // relation refers to value\n            keyValueRelation.Ids.forEach(function (valueId) {\n                var valueBlock = blockMap[valueId];\n                var contents = extractContentsFromBlock(valueBlock, blockMap);\n                valueText = contents.text;\n                if (contents.selected != null)\n                    valueSelected = contents.selected;\n            });\n        }\n    });\n    return {\n        key: keyText,\n        value: { text: valueText, selected: valueSelected },\n        polygon: getPolygon(keyBlock.Geometry),\n        boundingBox: getBoundingBox(keyBlock.Geometry),\n    };\n}\n/**\n * Extracts text and selection from input block's children.\n * @param {Textract.Block}} block - Block that we want to extract contents from.\n * @param {[id: string]: Textract.Block} blockMap - Maps block Ids to blocks.\n */\nexport function extractContentsFromBlock(block, blockMap) {\n    var words = '';\n    var isSelected;\n    if (!block.Relationships) {\n        // some block might have no content\n        return { text: '', selected: undefined };\n    }\n    block.Relationships.forEach(function (relation) {\n        relation.Ids.forEach(function (contentId) {\n            var contentBlock = blockMap[contentId];\n            if (contentBlock.BlockType === 'WORD') {\n                words += contentBlock.Text + ' ';\n            }\n            else if (contentBlock.BlockType === 'SELECTION_ELEMENT') {\n                isSelected = contentBlock.SelectionStatus === 'SELECTED' ? true : false;\n            }\n        });\n    });\n    words = words.substr(0, words.length - 1); // remove trailing space.\n    return { text: words, selected: isSelected };\n}\n//# sourceMappingURL=IdentifyTextUtils.js.map"]},"metadata":{},"sourceType":"module"}