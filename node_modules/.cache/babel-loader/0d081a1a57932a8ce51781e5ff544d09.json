{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar SHORT_TO_HEX = {};\nvar HEX_TO_SHORT = {};\nfor (var i = 0; i < 256; i++) {\n  var encodedByte = i.toString(16).toLowerCase();\n  if (encodedByte.length === 1) {\n    encodedByte = \"0\" + encodedByte;\n  }\n  SHORT_TO_HEX[i] = encodedByte;\n  HEX_TO_SHORT[encodedByte] = i;\n}\n/**\n * Converts a hexadecimal encoded string to a Uint8Array of bytes.\n *\n * @param encoded The hexadecimal encoded string\n */\nfunction fromHex(encoded) {\n  if (encoded.length % 2 !== 0) {\n    throw new Error(\"Hex encoded strings must have an even number length\");\n  }\n  var out = new Uint8Array(encoded.length / 2);\n  for (var i = 0; i < encoded.length; i += 2) {\n    var encodedByte = encoded.substr(i, 2).toLowerCase();\n    if (encodedByte in HEX_TO_SHORT) {\n      out[i / 2] = HEX_TO_SHORT[encodedByte];\n    } else {\n      throw new Error(\"Cannot decode unrecognized sequence \" + encodedByte + \" as hexadecimal\");\n    }\n  }\n  return out;\n}\nexports.fromHex = fromHex;\n/**\n * Converts a Uint8Array of binary data to a hexadecimal encoded string.\n *\n * @param bytes The binary data to encode\n */\nfunction toHex(bytes) {\n  var out = \"\";\n  for (var i = 0; i < bytes.byteLength; i++) {\n    out += SHORT_TO_HEX[bytes[i]];\n  }\n  return out;\n}\nexports.toHex = toHex;","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":";;;;;AAAA,IAAM,YAAY,GAA8B,CAAA,CAAE;AAClD,IAAM,YAAY,GAA8B,CAAA,CAAE;AAElD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;EAC5B,IAAI,WAAW,GAAG,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,WAAW,CAAA,CAAE;EAC9C,IAAI,WAAW,CAAC,MAAM,KAAK,CAAC,EAAE;IAC5B,WAAW,GAAG,GAAA,GAAI,WAAa;EAChC;EAED,YAAY,CAAC,CAAC,CAAC,GAAG,WAAW;EAC7B,YAAY,CAAC,WAAW,CAAC,GAAG,CAAC;AAC9B;AAED;;;;AAIG;AACH,SAAgB,OAAO,CAAC,OAAe,EAAA;EACrC,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IAC5B,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC;EACvE;EAED,IAAM,GAAG,GAAG,IAAI,UAAU,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;EAC9C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;IAC1C,IAAM,WAAW,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,CAAA,CAAE;IACtD,IAAI,WAAW,IAAI,YAAY,EAAE;MAC/B,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY,CAAC,WAAW,CAAC;KACvC,MAAM;MACL,MAAM,IAAI,KAAK,CACb,sCAAA,GAAuC,WAAW,GAAA,iBAAiB,CACpE;IACF;EACF;EAED,OAAO,GAAG;AACZ;AAlBA,OAAA,CAAA,OAAA,GAAA,OAAA;AAoBA;;;;AAIG;AACH,SAAgB,KAAK,CAAC,KAAiB,EAAA;EACrC,IAAI,GAAG,GAAG,EAAE;EACZ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,UAAU,EAAE,CAAC,EAAE,EAAE;IACzC,GAAG,IAAI,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;EAC9B;EAED,OAAO,GAAG;AACZ;AAPA,OAAA,CAAA,KAAA,GAAA,KAAA","sourceRoot":"./src/","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SHORT_TO_HEX = {};\nvar HEX_TO_SHORT = {};\nfor (var i = 0; i < 256; i++) {\n    var encodedByte = i.toString(16).toLowerCase();\n    if (encodedByte.length === 1) {\n        encodedByte = \"0\" + encodedByte;\n    }\n    SHORT_TO_HEX[i] = encodedByte;\n    HEX_TO_SHORT[encodedByte] = i;\n}\n/**\n * Converts a hexadecimal encoded string to a Uint8Array of bytes.\n *\n * @param encoded The hexadecimal encoded string\n */\nfunction fromHex(encoded) {\n    if (encoded.length % 2 !== 0) {\n        throw new Error(\"Hex encoded strings must have an even number length\");\n    }\n    var out = new Uint8Array(encoded.length / 2);\n    for (var i = 0; i < encoded.length; i += 2) {\n        var encodedByte = encoded.substr(i, 2).toLowerCase();\n        if (encodedByte in HEX_TO_SHORT) {\n            out[i / 2] = HEX_TO_SHORT[encodedByte];\n        }\n        else {\n            throw new Error(\"Cannot decode unrecognized sequence \" + encodedByte + \" as hexadecimal\");\n        }\n    }\n    return out;\n}\nexports.fromHex = fromHex;\n/**\n * Converts a Uint8Array of binary data to a hexadecimal encoded string.\n *\n * @param bytes The binary data to encode\n */\nfunction toHex(bytes) {\n    var out = \"\";\n    for (var i = 0; i < bytes.byteLength; i++) {\n        out += SHORT_TO_HEX[bytes[i]];\n    }\n    return out;\n}\nexports.toHex = toHex;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}