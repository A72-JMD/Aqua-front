{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar buffer_1 = require(\"buffer\");\nvar is_array_buffer_1 = require(\"@aws-sdk/is-array-buffer\");\nfunction fromArrayBuffer(input, offset, length) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n  if (length === void 0) {\n    length = input.byteLength - offset;\n  }\n  if (!is_array_buffer_1.isArrayBuffer(input)) {\n    throw new Error(\"argument passed to fromArrayBuffer was not an ArrayBuffer\");\n  }\n  if (typeof buffer_1.Buffer.from === \"function\" && buffer_1.Buffer.from !== Uint8Array.from) {\n    return buffer_1.Buffer.from(input, offset, length);\n  }\n  // Any version of node that supports the optional offset and length\n  // parameters, which were added in Node 6.0.0, will support Buffer.from and\n  // have already returned. Throw if offset is not 0 or if length differs from\n  // the underlying buffer's length.\n  if (offset !== 0 || length !== input.byteLength) {\n    throw new Error(\"Unable to convert TypedArray to Buffer in Node \" + process.version);\n  }\n  return new buffer_1.Buffer(input);\n}\nexports.fromArrayBuffer = fromArrayBuffer;\nfunction fromString(input, encoding) {\n  if (typeof input !== \"string\") {\n    throw new Error(\"argument passed to fromString was not a string\");\n  }\n  if (typeof buffer_1.Buffer.from === \"function\" && buffer_1.Buffer.from !== Uint8Array.from) {\n    return buffer_1.Buffer.from(input, encoding);\n  }\n  return new buffer_1.Buffer(input, encoding);\n}\nexports.fromString = fromString;","map":{"version":3,"sources":["index.ts"],"names":[],"mappings":";;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AACA,IAAA,iBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;AAEA,SAAgB,eAAe,CAC7B,KAAkB,EAClB,MAAkB,EAClB,MAA0C,EAAA;EAD1C,IAAA,MAAA,KAAA,KAAA,CAAA,EAAA;IAAA,MAAA,GAAA,CAAkB;EAAA;EAClB,IAAA,MAAA,KAAA,KAAA,CAAA,EAAA;IAAA,MAAA,GAAiB,KAAK,CAAC,UAAU,GAAG,MAAM;EAAA;EAE1C,IAAI,CAAC,iBAAA,CAAA,aAAa,CAAC,KAAK,CAAC,EAAE;IACzB,MAAM,IAAI,KAAK,CACb,2DAA2D,CAC5D;EACF;EAED,IAAI,OAAO,QAAA,CAAA,MAAM,CAAC,IAAI,KAAK,UAAU,IAAI,QAAA,CAAA,MAAM,CAAC,IAAI,KAAK,UAAU,CAAC,IAAI,EAAE;IACxE,OAAO,QAAA,CAAA,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC;EAC1C;EAED;EACA;EACA;EACA;EACA,IAAI,MAAM,KAAK,CAAC,IAAI,MAAM,KAAK,KAAK,CAAC,UAAU,EAAE;IAC/C,MAAM,IAAI,KAAK,CACb,iDAAA,GAAkD,OAAO,CAAC,OAAS,CACpE;EACF;EACD,OAAO,IAAI,QAAA,CAAA,MAAM,CAAC,KAAK,CAAC;AAC1B;AAzBA,OAAA,CAAA,eAAA,GAAA,eAAA;AA2BA,SAAgB,UAAU,CACxB,KAAa,EACb,QASU,EAAA;EAEV,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;IAC7B,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC;EAClE;EAED,IAAI,OAAO,QAAA,CAAA,MAAM,CAAC,IAAI,KAAK,UAAU,IAAI,QAAA,CAAA,MAAM,CAAC,IAAI,KAAK,UAAU,CAAC,IAAI,EAAE;IACxE,OAAO,QAAA,CAAA,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC;EACpC;EAED,OAAO,IAAI,QAAA,CAAA,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC;AACpC;AAtBA,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"./src/","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar buffer_1 = require(\"buffer\");\nvar is_array_buffer_1 = require(\"@aws-sdk/is-array-buffer\");\nfunction fromArrayBuffer(input, offset, length) {\n    if (offset === void 0) { offset = 0; }\n    if (length === void 0) { length = input.byteLength - offset; }\n    if (!is_array_buffer_1.isArrayBuffer(input)) {\n        throw new Error(\"argument passed to fromArrayBuffer was not an ArrayBuffer\");\n    }\n    if (typeof buffer_1.Buffer.from === \"function\" && buffer_1.Buffer.from !== Uint8Array.from) {\n        return buffer_1.Buffer.from(input, offset, length);\n    }\n    // Any version of node that supports the optional offset and length\n    // parameters, which were added in Node 6.0.0, will support Buffer.from and\n    // have already returned. Throw if offset is not 0 or if length differs from\n    // the underlying buffer's length.\n    if (offset !== 0 || length !== input.byteLength) {\n        throw new Error(\"Unable to convert TypedArray to Buffer in Node \" + process.version);\n    }\n    return new buffer_1.Buffer(input);\n}\nexports.fromArrayBuffer = fromArrayBuffer;\nfunction fromString(input, encoding) {\n    if (typeof input !== \"string\") {\n        throw new Error(\"argument passed to fromString was not a string\");\n    }\n    if (typeof buffer_1.Buffer.from === \"function\" && buffer_1.Buffer.from !== Uint8Array.from) {\n        return buffer_1.Buffer.from(input, encoding);\n    }\n    return new buffer_1.Buffer(input, encoding);\n}\nexports.fromString = fromString;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}