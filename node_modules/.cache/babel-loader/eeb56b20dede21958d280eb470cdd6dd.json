{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar crc32_1 = require(\"@aws-crypto/crc32\");\n// All prelude components are unsigned, 32-bit integers\nvar PRELUDE_MEMBER_LENGTH = 4;\n// The prelude consists of two components\nvar PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;\n// Checksums are always CRC32 hashes.\nvar CHECKSUM_LENGTH = 4;\n// Messages must include a full prelude, a prelude checksum, and a message checksum\nvar MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\n/**\n * @internal\n */\nfunction splitMessage(_a) {\n  var byteLength = _a.byteLength,\n    byteOffset = _a.byteOffset,\n    buffer = _a.buffer;\n  if (byteLength < MINIMUM_MESSAGE_LENGTH) {\n    throw new Error('Provided message too short to accommodate event stream message overhead');\n  }\n  var view = new DataView(buffer, byteOffset, byteLength);\n  var messageLength = view.getUint32(0, false);\n  if (byteLength !== messageLength) {\n    throw new Error('Reported message length does not match received message length');\n  }\n  var headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);\n  var expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);\n  var expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);\n  var checksummer = new crc32_1.Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));\n  if (expectedPreludeChecksum !== checksummer.digest()) {\n    throw new Error(\"The prelude checksum specified in the message (\" + expectedPreludeChecksum + \") does not match the calculated CRC32 checksum (\" + checksummer.digest() + \")\");\n  }\n  checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));\n  if (expectedMessageChecksum !== checksummer.digest()) {\n    throw new Error(\"The message checksum (\" + checksummer.digest() + \") did not match the expected value of \" + expectedMessageChecksum);\n  }\n  return {\n    headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),\n    body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))\n  };\n}\nexports.splitMessage = splitMessage;","map":{"version":3,"sources":["../src/splitMessage.ts"],"names":[],"mappings":";;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAEA;AACA,IAAM,qBAAqB,GAAG,CAAC;AAC/B;AACA,IAAM,cAAc,GAAG,qBAAqB,GAAG,CAAC;AAChD;AACA,IAAM,eAAe,GAAG,CAAC;AACzB;AACA,IAAM,sBAAsB,GAAG,cAAc,GAAG,eAAe,GAAG,CAAC;AAUnE;;AAEG;AACH,SAAgB,YAAY,CACxB,EAAmD,EAAA;MAAjD,UAAA,GAAA,EAAA,CAAA,UAAU;IAAE,UAAA,GAAA,EAAA,CAAA,UAAU;IAAE,MAAA,GAAA,EAAA,CAAA,MAAM;EAEhC,IAAI,UAAU,GAAG,sBAAsB,EAAE;IACrC,MAAM,IAAI,KAAK,CACX,yEAAyE,CAC5E;EACJ;EAED,IAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,MAAM,EAAE,UAAU,EAAE,UAAU,CAAC;EAEzD,IAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC;EAE9C,IAAI,UAAU,KAAK,aAAa,EAAE;IAC9B,MAAM,IAAI,KAAK,CACX,gEAAgE,CACnE;EACJ;EAED,IAAM,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,qBAAqB,EAAE,KAAK,CAAC;EACjE,IAAM,uBAAuB,GAAG,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,KAAK,CAAC;EACrE,IAAM,uBAAuB,GAAG,IAAI,CAAC,SAAS,CAC1C,UAAU,GAAG,eAAe,EAC5B,KAAK,CACR;EAED,IAAM,WAAW,GAAI,IAAI,OAAA,CAAA,KAAK,CAAL,CAAK,CAAE,MAAM,CAClC,IAAI,UAAU,CAAC,MAAM,EAAE,UAAU,EAAE,cAAc,CAAC,CACrD;EACD,IACI,uBAAuB,KAAK,WAAW,CAAC,MAAM,CAAA,CAAE,EAClD;IACE,MAAM,IAAI,KAAK,CACX,iDAAA,GACI,uBAAuB,GAAA,kDAAA,GAEvB,WAAW,CAAC,MAAM,CAAA,CAAE,GAAA,GACrB,CACN;EACJ;EAED,WAAW,CAAC,MAAM,CAAC,IAAI,UAAU,CAC7B,MAAM,EACN,UAAU,GAAG,cAAc,EAC3B,UAAU,IAAI,cAAc,GAAG,eAAe,CAAC,CAClD,CAAC;EACF,IAAI,uBAAuB,KAAK,WAAW,CAAC,MAAM,CAAA,CAAE,EAAE;IAClD,MAAM,IAAI,KAAK,CACX,wBAAA,GACI,WAAW,CAAC,MAAM,CAAA,CAAE,GAAA,wCAAA,GACiB,uBAAyB,CACrE;EACJ;EAED,OAAO;IACH,OAAO,EAAE,IAAI,QAAQ,CACjB,MAAM,EACN,UAAU,GAAG,cAAc,GAAG,eAAe,EAC7C,YAAY,CACf;IACD,IAAI,EAAE,IAAI,UAAU,CAChB,MAAM,EACN,UAAU,GAAG,cAAc,GAAG,eAAe,GAAG,YAAY,EAC5D,aAAa,GAAG,YAAY,IACxB,cAAc,GAAG,eAAe,GAAG,eAAe,CACrD;GAER;AACL;AApEA,OAAA,CAAA,YAAA,GAAA,YAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar crc32_1 = require(\"@aws-crypto/crc32\");\n// All prelude components are unsigned, 32-bit integers\nvar PRELUDE_MEMBER_LENGTH = 4;\n// The prelude consists of two components\nvar PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;\n// Checksums are always CRC32 hashes.\nvar CHECKSUM_LENGTH = 4;\n// Messages must include a full prelude, a prelude checksum, and a message checksum\nvar MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;\n/**\n * @internal\n */\nfunction splitMessage(_a) {\n    var byteLength = _a.byteLength, byteOffset = _a.byteOffset, buffer = _a.buffer;\n    if (byteLength < MINIMUM_MESSAGE_LENGTH) {\n        throw new Error('Provided message too short to accommodate event stream message overhead');\n    }\n    var view = new DataView(buffer, byteOffset, byteLength);\n    var messageLength = view.getUint32(0, false);\n    if (byteLength !== messageLength) {\n        throw new Error('Reported message length does not match received message length');\n    }\n    var headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);\n    var expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);\n    var expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);\n    var checksummer = (new crc32_1.Crc32).update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));\n    if (expectedPreludeChecksum !== checksummer.digest()) {\n        throw new Error(\"The prelude checksum specified in the message (\" + expectedPreludeChecksum + \") does not match the calculated CRC32 checksum (\" + checksummer.digest() + \")\");\n    }\n    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));\n    if (expectedMessageChecksum !== checksummer.digest()) {\n        throw new Error(\"The message checksum (\" + checksummer.digest() + \") did not match the expected value of \" + expectedMessageChecksum);\n    }\n    return {\n        headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),\n        body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))\n    };\n}\nexports.splitMessage = splitMessage;\n//# sourceMappingURL=splitMessage.js.map"]},"metadata":{},"sourceType":"script"}